import pandas as pd
import random
import sys
import math

random.seed(0)


def load_data(filename):
    df = pd.read_csv(filename)
    return df

def load_from_txt(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
        queries = [line.strip() for line in lines]
    return queries

def initial_setup(bidders):
    """
        Input: 
          bidders: dataframe
        Returns:
          budgets: dictionary of advertisers with their budgets
          edges: dictionary with a list of neighbours for a keyword
    """
    # let's keep a dict of advertiser with their budget
    # also a list of advertiser willing to bid for a specific keyword (neighbours)
    rows = bidders.shape[0]
    budgets = dict()
    edges = dict()
    for i in range(rows):
        if bidders.iloc[i]['Advertiser'] not in budgets:
            budgets[bidders.iloc[i]['Advertiser']] = bidders.iloc[i]['Budget']
        
        if bidders.iloc[i]['Keyword'] not in edges:
            edges[bidders.iloc[i]['Keyword']] = [[bidders.iloc[i]['Advertiser'], bidders.iloc[i]['Bid Value']]]
        else:
            edges[bidders.iloc[i]['Keyword']].append([bidders.iloc[i]['Advertiser'], bidders.iloc[i]['Bid Value']])
    return budgets, edges

def revenue_greedy(budgets, edges, queries):
    """
        Input:
          budgets: dictionary of advertisers with their budgets
          edges: dictionary with a list of neighbours for a keyword
          queries: list of keyword queries
        Returns:
          Maximum revenue generated by greedy approach
    """
    revenue = 0.0
    for q in queries:
        max_bid = 0
        highest = 0
        neighbours = edges[q]
        for neighbour in neighbours:
            k, v = neighbour[0], neighbour[1]
            if v > max_bid and v<=budgets[k]:
                max_bid = v
                highest = k
                
        revenue += max_bid
        budgets[highest] -= max_bid
    return revenue

def psi(budget_left, budgets, u):
    xu = (budgets[u] - budget_left[u])/budgets[u]
    value = math.exp(xu-1)
    return 1 - value

def revenue_msvv(budgets, edges, queries):
    """
        Input:
          budgets: dictionary of advertisers with their budgets
          edges: dictionary with a list of neighbours for a keyword
          queries: list of keyword queries
        Returns:
          Maximum revenue generated by MSVV
    """
    budget_left = dict(budgets)     #deep copy for tracking remaining budget
    revenue = 0.0
    for q in queries:
        max_bid = 0
        highest = 0
        max_psi_xu = -1
        neighbours = edges[q]
        for neighbour in neighbours:
            k, v = neighbour[0], neighbour[1]
            if v <= budget_left[k]:
                psi_xu = psi(budget_left, budgets, k)
                if v*psi_xu > max_psi_xu:
                    max_bid = v
                    highest = k
                    max_psi_xu = v*psi_xu
        budget_left[highest] -= max_bid
        revenue += max_bid
    
    return revenue

def revenue_balance(budgets, edges, queries):
    """
        Input:
          budgets: dictionary of advertisers with their budgets
          edges: dictionary with a list of neighbours for a keyword
          queries: list of keyword queries
        Returns:
          Maximum revenue generated by balance method
    """
    budget_left = dict(budgets)
    revenue = 0.0
    for q in queries:
        max_bid = 0
        highest = 0
        max_unspent = -1
        neighbours = edges[q]
        for neighbour in neighbours:
            k, v = neighbour[0], neighbour[1]
            if v <= budget_left[k] and budget_left[k] > max_unspent:
                max_bid = v
                highest = k
                max_unspent = budget_left[k]
        budget_left[highest] -= max_bid
        revenue += max_bid
    
    return revenue

def competitive_ratio(method, budgets, edges, queries, n):
    """
        Input:
          method: greedy, msvv, balance
          budgets: dictionary of advertisers with their budgets
          edges: dictionary with a list of neighbours for a keyword
          queries: list of keyword queries
        Returns:
          competitive ratio 
    """
    revenue_sum = 0.0
    for i in range(n):
        random.shuffle(queries)
        if method == 'greedy':
            revenue_sum += revenue_greedy(budgets,edges, queries)
        elif method == 'msvv':
            revenue_sum += revenue_msvv(budgets, edges, queries)
        elif method == 'balance':
            revenue_sum += revenue_balance(budgets, edges, queries)

    ALG = revenue_sum / n
    OPT = sum(budgets.values())
    competitive_ratio = ALG / OPT
    return competitive_ratio


if __name__ == "__main__":
    if len(sys.argv) > 1:
        method = sys.argv[1]
        bidders = load_data('bidder_dataset.csv')
        queries = load_from_txt('queries.txt')
        budgets, edges = initial_setup(bidders)

        if method == 'greedy':
            revenue = revenue_greedy(budgets, edges, queries)
            competitive_ratio = competitive_ratio(method, budgets, edges, queries, 100)
            print(round(revenue, 2))
            print(round(competitive_ratio, 2))
        
        elif method == 'msvv':
            revenue = revenue_msvv(budgets, edges, queries)
            competitive_ratio = competitive_ratio(method, budgets, edges, queries, 100)
            print(round(revenue, 2))
            print(round(competitive_ratio, 2))
        
        elif method == 'balance':
            revenue = revenue_balance(budgets, edges, queries)
            competitive_ratio = competitive_ratio(method, budgets, edges, queries, 100)
            print(round(revenue, 2))
            print(round(competitive_ratio, 2))
        
        else:
            print('Not a valid method!')
    
    else:
        print('Please give correct number of arguments!')

